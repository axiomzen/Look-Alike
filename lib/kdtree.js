// Generated by CoffeeScript 1.6.3
(function() {
  var KDtree, util;

  util = require('./util');

  KDtree = (function() {
    KDtree.prototype.getRoot = function() {
      return this._tree;
    };

    function KDtree(objects, keys) {
      var k, v, _helper,
        _this = this;
      this.objects = objects;
      this.keys = keys;
      if (this.keys == null) {
        this.keys = (function() {
          var _ref, _results;
          _ref = this.objects[0];
          _results = [];
          for (k in _ref) {
            v = _ref[k];
            _results.push(k);
          }
          return _results;
        }).call(this);
      }
      this.stdv = util.allStdvs(this.keys, this.objects);
      _helper = function(objects, depth) {
        var key, len, median, medianVal, node;
        if (!objects.length) {
          return null;
        }
        len = _this.keys.length;
        key = _this.keys[depth % len];
        objects.sort(function(a, b) {
          return a[key] - b[key];
        });
        medianVal = objects[Math.floor(objects.length / 2)][key];
        median = ((function() {
          var _i, _len, _results;
          _results = [];
          for (_i = 0, _len = objects.length; _i < _len; _i++) {
            v = objects[_i];
            _results.push(v[key]);
          }
          return _results;
        })()).indexOf(medianVal);
        return node = {
          val: objects[median],
          left: _helper(objects.slice(0, median), depth + 1),
          right: _helper(objects.slice(median + 1), depth + 1)
        };
      };
      this._tree = _helper(this.objects, 0);
    }

    KDtree.prototype.query = function(subject, options) {
      var BPQ, Q, root, _helper,
        _this = this;
      if (options) {
        if (!options.k) {
          options.k = 1;
        }
        if (!options.normalize) {
          options.normalize = true;
        }
      } else {
        options = {
          k: 1,
          normalize: true
        };
      }
      BPQ = require('./bpq');
      Q = new BPQ(options.k);
      _helper = function(node, depth) {
        var attr_dist, dist, goLeft, key, len;
        if (!node) {
          return null;
        }
        len = _this.keys.length;
        key = _this.keys[depth % len];
        if (options.normalize) {
          dist = util.distance(subject, node.val, {
            stdv: _this.stdv,
            weights: options.weights
          });
        } else {
          dist = util.distance(subject, node.val, {
            weights: options.weights
          });
        }
        Q.insert(node.val, dist);
        goLeft = subject[key] < node.val[key];
        if (goLeft) {
          _helper(node.left, depth + 1);
        } else {
          _helper(node.right, depth + 1);
        }
        if (options.normalize) {
          attr_dist = Math.abs(node.val[key] - subject[key]) / _this.stdv[key];
        } else {
          attr_dist = Math.abs(node.val[key] - subject[key]);
        }
        if (options.weights) {
          attr_dist *= options.weights[key];
        }
        if (options.k > Q.getSize() || attr_dist < Q.getMaxPriority()) {
          if (goLeft) {
            _helper(node.right, depth + 1);
          } else {
            _helper(node.left, depth + 1);
          }
        }
        return Q.getObjects();
      };
      root = this.getRoot();
      return _helper(root, 0);
    };

    return KDtree;

  })();

  module.exports = KDtree;

}).call(this);
